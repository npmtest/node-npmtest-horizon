{"/home/travis/build/npmtest/node-npmtest-horizon/test.js":"/* istanbul instrument in package npmtest_horizon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-horizon/lib.npmtest_horizon.js":"/* istanbul instrument in package npmtest_horizon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_horizon = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_horizon = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-horizon/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-horizon && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_horizon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_horizon\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_horizon.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_horizon.rollup.js'] =\n            local.assetsDict['/assets.npmtest_horizon.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_horizon.__dirname + '/lib.npmtest_horizon.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/main.js":"#!/usr/bin/env node\n'use strict';\n\n// To support `pidof horizon`, by default it shows in `pidof node`\nprocess.title = 'horizon';\n\nconst chalk = require('chalk');\nconst path = require('path');\n\nconst initCommand = require('./init');\nconst serveCommand = require('./serve');\nconst versionCommand = require('./version');\nconst createCertCommand = require('./create-cert');\nconst schemaCommand = require('./schema');\nconst makeTokenCommand = require('./make-token');\nconst migrateCommand = require('./migrate');\n\nconst NiceError = require('./utils/nice_error');\n// Mapping from command line strings to modules. To add a new command,\n// add an entry in this object, and create a module with the following\n// exported:\n// - run: main function for the command\n// - description: a string to display in the hz help text\nconst commands = {\n  init: initCommand,\n  serve: serveCommand,\n  version: versionCommand,\n  'create-cert': createCertCommand,\n  'make-token': makeTokenCommand,\n  schema: schemaCommand,\n  migrate: migrateCommand,\n};\n\nconst programName = path.basename(process.argv[1]);\n\nconst help = () => {\n  console.log(`Usage: ${programName} subcommand [args...]`);\n  console.log('Available subcommands:');\n  Object.keys(commands).forEach((cmdName) =>\n    console.log(`  ${cmdName} - ${commands[cmdName].description}`)\n  );\n};\n\nconst allArgs = process.argv.slice(2);\nif (allArgs.length === 0) {\n  help();\n  process.exit(1);\n}\n\nconst cmdName = allArgs[0];\nconst cmdArgs = allArgs.slice(1);\n\nif (cmdName === '-h' || cmdName === '--help' || cmdName === 'help') {\n  help();\n  process.exit(0);\n}\n\nconst command = commands[cmdName];\nif (!command) {\n  console.error(chalk.red.bold(\n    `No such subcommand ${cmdName}, run with -h for help`));\n  process.exit(1);\n}\n\nconst done = (err) => {\n  if (err) {\n    const errMsg = (err instanceof NiceError) ?\n            err.niceString({ contextSize: 2 }) : err.message;\n    console.error(chalk.red.bold(errMsg));\n    process.exit(1);\n  } else {\n    process.exit(0);\n  }\n};\n\ntry {\n  command.run(cmdArgs).then(() => done()).catch(done);\n} catch (err) {\n  done(err);\n}\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/init.js":"/* global require, module */\n\n'use strict';\n\nconst fs = require('fs');\nconst crypto = require('crypto');\nconst process = require('process');\nconst argparse = require('argparse');\nconst checkProjectName = require('./utils/check-project-name');\nconst rethrow = require('./utils/rethrow');\n\nconst makeIndexHTML = (projectName) => `\\\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <script src=\"/horizon/horizon.js\"></script>\n    <script>\n      var horizon = Horizon();\n      horizon.onReady(function() {\n        document.querySelector('h1').innerHTML = '${projectName} works!'\n      });\n      horizon.connect();\n    </script>\n  </head>\n  <body>\n   <marquee direction=\"left\"><h1></h1></marquee>\n  </body>\n</html>\n`;\n\nconst makeDefaultConfig = (projectName) => `\\\n# This is a TOML file\n\n###############################################################################\n# IP options\n# 'bind' controls which local interfaces will be listened on\n# 'port' controls which port will be listened on\n#------------------------------------------------------------------------------\n# bind = [ \"localhost\" ]\n# port = 8181\n\n\n###############################################################################\n# HTTPS Options\n# 'secure' will disable HTTPS and use HTTP instead when set to 'false'\n# 'key_file' and 'cert_file' are required for serving HTTPS\n#------------------------------------------------------------------------------\n# secure = true\n# key_file = \"horizon-key.pem\"\n# cert_file = \"horizon-cert.pem\"\n\n\n###############################################################################\n# App Options\n# 'project_name' sets the name of the RethinkDB database used to store the\n#                application state\n# 'serve_static' will serve files from the given directory over HTTP/HTTPS\n#------------------------------------------------------------------------------\nproject_name = \"${projectName}\"\n# serve_static = \"dist\"\n\n\n###############################################################################\n# Data Options\n# WARNING: these should probably not be enabled on a publically accessible\n# service.  Tables and indexes are not lightweight objects, and allowing them\n# to be created like this could open the service up to denial-of-service\n# attacks.\n# 'auto_create_collection' creates a collection when one is needed but does not exist\n# 'auto_create_index' creates an index when one is needed but does not exist\n#------------------------------------------------------------------------------\n# auto_create_collection = false\n# auto_create_index = false\n\n\n###############################################################################\n# RethinkDB Options\n# 'connect' and 'start_rethinkdb' are mutually exclusive\n# 'connect' will connect to an existing RethinkDB instance\n# 'start_rethinkdb' will run an internal RethinkDB instance\n# 'rdb_timeout' is the number of seconds to wait when connecting to RethinkDB\n#------------------------------------------------------------------------------\n# connect = \"localhost:28015\"\n# start_rethinkdb = false\n# rdb_timeout = 30\n\n\n###############################################################################\n# Debug Options\n# 'debug' enables debug log statements\n#------------------------------------------------------------------------------\n# debug = false\n\n\n###############################################################################\n# Authentication Options\n# Each auth subsection will add an endpoint for authenticating through the\n# specified provider.\n# 'token_secret' is the key used to sign jwts\n# 'allow_anonymous' issues new accounts to users without an auth provider\n# 'allow_unauthenticated' allows connections that are not tied to a user id\n# 'auth_redirect' specifies where users will be redirected to after login\n# 'access_control_allow_origin' sets a host that can access auth settings\n#   (typically your frontend host)\n#------------------------------------------------------------------------------\n# allow_anonymous = false\n# allow_unauthenticated = false\n# auth_redirect = \"/\"\n# access_control_allow_origin = \"\"\n#\n`;\n\nconst makeDefaultSchema = () => `\\\n[groups.admin]\n[groups.admin.rules.carte_blanche]\ntemplate = \"any()\"\n`;\n\nconst makeDefaultSecrets = () => `\\\ntoken_secret = \"${crypto.randomBytes(64).toString('base64')}\"\n\n###############################################################################\n# RethinkDB Options\n# 'rdb_user' is the user account to log in with when connecting to RethinkDB\n# 'rdb_password' is the password for the user account specified by 'rdb_user'\n#------------------------------------------------------------------------------\n# rdb_user = 'admin'\n# rdb_password = ''\n\n# [auth.auth0]\n# host = \"0000.00.auth0.com\"\n# id = \"0000000000000000000000000\"\n# secret = \"00000000000000000000000000000000000000000000000000\"\n#\n# [auth.facebook]\n# id = \"000000000000000\"\n# secret = \"00000000000000000000000000000000\"\n#\n# [auth.google]\n# id = \"00000000000-00000000000000000000000000000000.apps.googleusercontent.com\"\n# secret = \"000000000000000000000000\"\n#\n# [auth.twitter]\n# id = \"0000000000000000000000000\"\n# secret = \"00000000000000000000000000000000000000000000000000\"\n#\n# [auth.github]\n# id = \"00000000000000000000\"\n# secret = \"0000000000000000000000000000000000000000\"\n#\n# [auth.twitch]\n# id = \"0000000000000000000000000000000\"\n# secret = \"0000000000000000000000000000000\"\n#\n# [auth.slack]\n# id = \"0000000000000000000000000000000\"\n# secret = \"0000000000000000000000000000000\"\n`;\n\nconst gitignore = () => `\\\nrethinkdb_data\n**/*.log\n.hz/secrets.toml\n`;\n\nconst parseArguments = (args) => {\n  const parser = new argparse.ArgumentParser({ prog: 'hz init' });\n  parser.addArgument([ 'projectName' ],\n    { action: 'store',\n      help: 'Name of directory to create. Defaults to current directory',\n      nargs: '?',\n    }\n  );\n  return parser.parseArgs(args);\n};\n\nconst fileExists = (pathName) => {\n  try {\n    fs.statSync(pathName);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nconst maybeMakeDir = (createDir, dirName) => {\n  if (createDir) {\n    try {\n      fs.mkdirSync(dirName);\n      console.info(`Created new project directory ${dirName}`);\n    } catch (e) {\n      throw rethrow(e,\n        `Couldn't make directory ${dirName}: ${e.message}`);\n    }\n  } else {\n    console.info(`Initializing in existing directory ${dirName}`);\n  }\n};\n\nconst maybeChdir = (chdirTo) => {\n  if (chdirTo) {\n    try {\n      process.chdir(chdirTo);\n    } catch (e) {\n      if (e.code === 'ENOTDIR') {\n        throw rethrow(e, `${chdirTo} is not a directory`);\n      } else {\n        throw rethrow(e, `Couldn't chdir to ${chdirTo}: ${e.message}`);\n      }\n    }\n  }\n};\n\nconst populateDir = (projectName, dirWasPopulated, chdirTo, dirName) => {\n  const niceDir = chdirTo ? `${dirName}/` : '';\n  if (!dirWasPopulated && !fileExists('src')) {\n    fs.mkdirSync('src');\n    console.info(`Created ${niceDir}src directory`);\n  }\n  if (!dirWasPopulated && !fileExists('dist')) {\n    fs.mkdirSync('dist');\n    console.info(`Created ${niceDir}dist directory`);\n\n    fs.appendFileSync('./dist/index.html', makeIndexHTML(projectName));\n    console.info(`Created ${niceDir}dist/index.html example`);\n  }\n\n  if (!fileExists('.hz')) {\n    fs.mkdirSync('.hz');\n    console.info(`Created ${niceDir}.hz directory`);\n  }\n\n  // Default permissions\n  const permissionGeneral = {\n    encoding: 'utf8',\n    mode: 0o666,\n  };\n\n  const permissionSecret = {\n    encoding: 'utf8',\n    mode: 0o600, // Secrets are put in this config, so set it user, read/write only\n  };\n\n  // Create .gitignore if it doesn't exist\n  if (!fileExists('.gitignore')) {\n    fs.appendFileSync(\n      '.gitignore',\n      gitignore(),\n      permissionGeneral\n    );\n    console.info(`Created ${niceDir}.gitignore`);\n  } else {\n    console.info('.gitignore already exists, not touching it.');\n  }\n\n  // Create .hz/config.toml if it doesn't exist\n  if (!fileExists('.hz/config.toml')) {\n    fs.appendFileSync(\n      '.hz/config.toml',\n      makeDefaultConfig(projectName),\n      permissionGeneral\n    );\n    console.info(`Created ${niceDir}.hz/config.toml`);\n  } else {\n    console.info('.hz/config.toml already exists, not touching it.');\n  }\n\n  // Create .hz/schema.toml if it doesn't exist\n  if (!fileExists('.hz/schema.toml')) {\n    fs.appendFileSync(\n      '.hz/schema.toml',\n      makeDefaultSchema(),\n      permissionGeneral\n    );\n    console.info(`Created ${niceDir}.hz/schema.toml`);\n  } else {\n    console.info('.hz/schema.toml already exists, not touching it.');\n  }\n\n  // Create .hz/secrets.toml if it doesn't exist\n  if (!fileExists('.hz/secrets.toml')) {\n    fs.appendFileSync(\n      '.hz/secrets.toml',\n      makeDefaultSecrets(),\n      permissionSecret\n    );\n    console.info(`Created ${niceDir}.hz/secrets.toml`);\n  } else {\n    console.info('.hz/secrets.toml already exists, not touching it.');\n  }\n};\n\nconst run = (args) =>\n  Promise.resolve(args)\n    .then(parseArguments)\n    .then((parsed) => {\n      const check = checkProjectName(\n        parsed.projectName,\n        process.cwd(),\n        fs.readdirSync('.')\n      );\n      const projectName = check.projectName;\n      const dirName = check.dirName;\n      const chdirTo = check.chdirTo;\n      const createDir = check.createDir;\n      maybeMakeDir(createDir, dirName);\n      maybeChdir(chdirTo);\n\n      // Before we create things, check if the directory is empty\n      const dirWasPopulated = fs.readdirSync(process.cwd()).length !== 0;\n      populateDir(projectName, dirWasPopulated, chdirTo, dirName);\n    });\n\nmodule.exports = {\n  run,\n  description: 'Initialize a horizon app directory',\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/check-project-name.js":"'use strict';\n\nconst path = require('path');\nconst basename = path.basename;\nconst join = path.join;\n\nconst fixableProjectName = /^[A-Za-z0-9_-]+$/;\nconst unfixableChars = /[^A-Za-z0-9_-]/g;\n\nconst dehyphenate = (name) => name.replace(/-/g, '_');\n\nconst shouldCreateDir = (prospectiveName, dirList) => {\n  if (prospectiveName === '.' ||\n      prospectiveName == null ||\n      !fixableProjectName.test(prospectiveName)) {\n    return false;\n  } else if (dirList.indexOf(prospectiveName) === -1) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nmodule.exports = (prospectiveName, cwd, dirList) => {\n  let chdirTo = prospectiveName != null ?\n        join(cwd, prospectiveName) : cwd;\n  const createDir = shouldCreateDir(prospectiveName, dirList);\n  if (prospectiveName === '.' || prospectiveName == null) {\n    // eslint-disable-next-line no-param-reassign\n    prospectiveName = basename(cwd);\n    chdirTo = false;\n  }\n  if (fixableProjectName.test(prospectiveName)) {\n    return {\n      dirName: prospectiveName,\n      projectName: dehyphenate(prospectiveName),\n      chdirTo,\n      createDir,\n    };\n  } else {\n    const invalids = prospectiveName.match(unfixableChars).join('');\n    throw new Error(`Invalid characters in project name: ${invalids}`);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/rethrow.js":"'use strict';\n\n// Returns a new Error with the given message. Combines the stack\n// traces with the old error, and removes itself from the stack trace.\nmodule.exports = (e, newMessage) => {\n  let e2;\n  if (typeof newMessage === 'string') {\n    e2 = new Error(newMessage);\n    e2.stack = e2.stack.split('\\n');\n    e2.stack.splice(1, 1); // Remove rethrow from stack trace\n  } else {\n    e2 = newMessage;\n  }\n  e2.stack += '\\n\\n  ==== Original stack trace ====\\n\\n';\n  e2.stack += e.stack;\n  return e2;\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/serve.js":"'use strict';\n\nconst chalk = require('chalk');\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst get_type = require('mime-types').contentType;\nconst http = require('http');\nconst https = require('https');\nconst open = require('open');\nconst path = require('path');\nconst argparse = require('argparse');\nconst url = require('url');\n\nconst config = require('./utils/config');\nconst start_rdb_server = require('./utils/start_rdb_server');\nconst change_to_project_dir = require('./utils/change_to_project_dir');\nconst NiceError = require('./utils/nice_error.js');\nconst interrupt = require('./utils/interrupt');\nconst schema = require('./schema');\n\nconst horizon_server = require('@horizon/server');\nconst logger = horizon_server.logger;\n\nconst TIMEOUT_30_SECONDS = 30 * 1000;\n\nconst default_rdb_host = 'localhost';\nconst default_rdb_port = 28015;\nconst default_rdb_timeout = 20;\n\nconst parseArguments = (args) => {\n  const parser = new argparse.ArgumentParser({ prog: 'hz serve' });\n\n  parser.addArgument([ 'project_path' ],\n    { type: 'string', nargs: '?',\n      help: 'Change to this directory before serving' });\n\n  parser.addArgument([ '--project-name', '-n' ],\n    { type: 'string', action: 'store', metavar: 'NAME',\n      help: 'Name of the Horizon project. Determines the name of ' +\n            'the RethinkDB database that stores the project data.' });\n\n  parser.addArgument([ '--bind', '-b' ],\n    { type: 'string', action: 'append', metavar: 'HOST',\n      help: 'Local hostname to serve horizon on (repeatable).' });\n\n  parser.addArgument([ '--port', '-p' ],\n    { type: 'int', metavar: 'PORT',\n      help: 'Local port to serve horizon on.' });\n\n  parser.addArgument([ '--connect', '-c' ],\n    { type: 'string', metavar: 'HOST:PORT',\n      help: 'Host and port of the RethinkDB server to connect to.' });\n\n  parser.addArgument([ '--rdb-timeout' ],\n    { type: 'int', metavar: 'TIMEOUT',\n      help: 'Timeout period in seconds for the RethinkDB connection to be opened' });\n\n  parser.addArgument([ '--rdb-user' ],\n    { type: 'string', metavar: 'USER',\n      help: 'RethinkDB User' });\n\n  parser.addArgument([ '--rdb-password' ],\n    { type: 'string', metavar: 'PASSWORD',\n      help: 'RethinkDB Password' });\n\n  parser.addArgument([ '--key-file' ],\n    { type: 'string', metavar: 'PATH',\n      help: 'Path to the key file to use, defaults to \"./horizon-key.pem\".' });\n\n  parser.addArgument([ '--cert-file' ],\n    { type: 'string', metavar: 'PATH',\n      help: 'Path to the cert file to use, defaults to \"./horizon-cert.pem\".' });\n\n  parser.addArgument([ '--token-secret' ],\n    { type: 'string', metavar: 'SECRET',\n      help: 'Key for signing jwts' });\n\n  parser.addArgument([ '--allow-unauthenticated' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Whether to allow unauthenticated Horizon connections.' });\n\n  parser.addArgument([ '--allow-anonymous' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Whether to allow anonymous Horizon connections.' });\n\n  parser.addArgument([ '--debug' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Enable debug logging.' });\n\n  parser.addArgument([ '--secure' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Serve secure websockets, requires --key-file and ' +\n      '--cert-file if true, on by default.' });\n\n  parser.addArgument([ '--start-rethinkdb' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Start up a RethinkDB server in the current directory' });\n\n  parser.addArgument([ '--auto-create-collection' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Create collections used by requests if they do not exist.' });\n\n  parser.addArgument([ '--auto-create-index' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Create indexes used by requests if they do not exist.' });\n\n  parser.addArgument([ '--permissions' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Enables or disables checking permissions on requests.' });\n\n  parser.addArgument([ '--serve-static' ],\n    { type: 'string', metavar: 'PATH', nargs: '?', constant: './dist',\n      help: 'Serve static files from a directory, defaults to \"./dist\".' });\n\n  parser.addArgument([ '--dev' ],\n    { action: 'storeTrue',\n      help: 'Runs the server in development mode, this sets ' +\n      '--secure=no, ' +\n      '--permissions=no, ' +\n      '--auto-create-collection=yes, ' +\n      '--auto-create-index=yes, ' +\n      '--start-rethinkdb=yes, ' +\n      '--allow-unauthenticated=yes, ' +\n      '--allow-anonymous=yes ' +\n      'and --serve-static=./dist.' });\n\n  parser.addArgument([ '--schema-file' ],\n    { type: 'string', metavar: 'SCHEMA_FILE_PATH',\n      help: 'Path to the schema file to use, ' +\n      'will attempt to apply schema before starting Horizon server\".' });\n\n  parser.addArgument([ '--auth' ],\n    { type: 'string', action: 'append', metavar: 'PROVIDER,ID,SECRET', defaultValue: [ ],\n      help: 'Auth provider and options comma-separated, e.g. \"facebook,<id>,<secret>\".' });\n\n  parser.addArgument([ '--auth-redirect' ],\n    { type: 'string', metavar: 'URL',\n      help: 'The URL to redirect to upon completed authentication, defaults to \"/\".' });\n\n  parser.addArgument([ '--access-control-allow-origin' ],\n    { type: 'string', metavar: 'URL',\n      help: 'The URL of the host that can access auth settings, defaults to \"\".' });\n\n  parser.addArgument([ '--open' ],\n    { action: 'storeTrue',\n      help: 'Open index.html in the static files folder once Horizon is ready to' +\n      ' receive connections' });\n\n  return parser.parseArgs(args);\n};\n\n// Simple file server. 404s if file not found, 500 if file error,\n// otherwise serve it with a mime-type suggested by its file extension.\nconst serve_file = (filePath, res) => {\n  fs.access(filePath, fs.R_OK | fs.F_OK, (exists) => {\n    if (exists) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end(`File \"${filePath}\" not found\\n`);\n    } else {\n      fs.lstat(filePath, (err, stats) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end(`${err}\\n`);\n        } else if (stats.isFile()) {\n          fs.readFile(filePath, 'binary', (err2, file) => {\n            if (err2) {\n              res.writeHead(500, { 'Content-Type': 'text/plain' });\n              res.end(`${err2}\\n`);\n            } else {\n              const type = get_type(path.extname(filePath)) || false;\n              if (type) {\n                res.writeHead(200, { 'Content-Type': type });\n              } else {\n                res.writeHead(200);\n              }\n              res.end(file, 'binary');\n            }\n          });\n        } else if (stats.isDirectory()) {\n          serve_file(path.join(filePath, 'index.html'), res);\n        }\n      });\n    }\n  });\n};\n\nconst file_server = (distDir) => (req, res) => {\n  const reqPath = url.parse(req.url).pathname;\n  // Serve client files directly\n  if (reqPath === '/' || reqPath === '') {\n    serve_file(path.join(distDir, 'index.html'), res);\n  } else if (!reqPath.match(/\\/horizon\\/.*$/)) {\n    // All other static files come from the dist directory\n    serve_file(path.join(distDir, reqPath), res);\n  }\n  // Fall through otherwise. Should be handled by horizon server\n};\n\nconst initialize_servers = (ctor, opts) => {\n  const servers = [ ];\n  let numReady = 0;\n  return new Promise((resolve, reject) => {\n    opts.bind.forEach((host) => {\n      const srv = ctor().listen(opts.port, host);\n      servers.push(srv);\n      if (opts.serve_static) {\n        if (opts.serve_static === 'dist') {\n          // do nothing, this is the default\n        } else if (opts.project_path !== '.') {\n          const pth = path.join(opts.project_path, opts.serve_static);\n          console.info(`Static files being served from ${pth}`);\n        } else {\n          console.info(`Static files being served from ${opts.serve_static}`);\n        }\n        srv.on('request', file_server(opts.serve_static));\n      } else {\n        srv.on('request', (req, res) => {\n          res.writeHead(404);\n          res.end('404 Not Found');\n        });\n      }\n      srv.on('listening', () => {\n        const protocol = opts.secure ? 'https' : 'http';\n        console.info(`App available at ${protocol}://${srv.address().address}:` +\n                    `${srv.address().port}`);\n        if (++numReady === servers.length) {\n          resolve(servers);\n        }\n      });\n      srv.on('error', (err) => {\n        reject(new Error(`HTTP${opts.secure ? 'S' : ''} server: ${err}`));\n      });\n    });\n  });\n};\n\nconst create_insecure_servers = (opts) => {\n  if (!opts._dev_flag_used) {\n    console.error(chalk.red.bold('WARNING: Serving app insecurely.'));\n  }\n  return initialize_servers(() => new http.Server(), opts);\n};\n\nconst read_cert_file = (file, type) => {\n  try {\n    return fs.readFileSync(path.resolve(file));\n  } catch (err) {\n    const wasDefault = file.endsWith(`horizon-${type}.pem`);\n    let description;\n    const suggestions = [\n      `If you're running horizon for the first time, we recommend \\\nrunning horizon like ${chalk.white('hz serve --dev')} to get started without \\\nhaving to configure certificates.`,\n    ];\n    if (wasDefault) {\n      suggestions.push(\n        `If you have a ${type} file you'd like to use but they aren't in the \\\ndefault location, pass them in with the \\\n${chalk.white(`hz serve --${type}-file`)} option.`,\n        `You can explicitly disable security by passing \\\n${chalk.white('--secure=no')} to ${chalk.white('hz serve')}.`,\n        `You can generate a cert and key file for development by using the \\\n${chalk.white('hz create-cert')} command. Note that these certs won't be \\\nsigned by a certificate authority, so you will need to explicitly authorize \\\nthem in your browser.`\n      );\n      description = `In order to run the server in secure mode (the default), \\\nHorizon needs both a certificate file and a key file to encrypt websockets. \\\nBy default, it looks for horizon-key.pem and horizon-cert.pem \\\nfiles in the current directory.`;\n    } else {\n      // They supplied a cert or key file, so don't give the long\n      // explanation and irrelevant suggestions.\n      suggestions.unshift(`See if the ${type} filename was misspelled.`);\n      description = null;\n    }\n    throw new NiceError(\n      `Could not access the ${type} file ${file}`, {\n        description,\n        suggestions,\n      });\n  }\n};\n\nconst create_secure_servers = (opts) => {\n  const cert = read_cert_file(opts.cert_file, 'cert');\n  const key = read_cert_file(opts.key_file, 'key');\n  return initialize_servers(() => new https.Server({ key, cert }), opts);\n};\n\n// Command-line flags have the highest precedence, followed by environment variables,\n// then the config file, and finally the default values.\nconst processConfig = (parsed) => {\n  let options;\n\n  options = config.default_options();\n\n  options = config.merge_options(options,\n    config.read_from_config_file(parsed.project_path));\n\n  options = config.merge_options(options,\n    config.read_from_secrets_file(parsed.project_path));\n\n  options = config.merge_options(options, config.read_from_env());\n\n  options = config.merge_options(options, config.read_from_flags(parsed));\n\n  if (options.project_name === null) {\n    options.project_name = path.basename(path.resolve(options.project_path));\n  }\n\n  if (options.bind.indexOf('all') !== -1) {\n    options.bind = [ '0.0.0.0' ];\n  }\n\n  if (!options.rdb_host) {\n    options.rdb_host = default_rdb_host;\n  }\n\n  if (!options.rdb_port) {\n    options.rdb_port = default_rdb_port;\n  }\n\n  if (!options.rdb_timeout) {\n    options.rdb_timeout = default_rdb_timeout;\n  }\n\n  return options;\n};\n\nconst start_horizon_server = (http_servers, opts) =>\n  new horizon_server.Server(http_servers, {\n    auto_create_collection: opts.auto_create_collection,\n    auto_create_index: opts.auto_create_index,\n    permissions: opts.permissions,\n    project_name: opts.project_name,\n    access_control_allow_origin: opts.access_control_allow_origin,\n    auth: {\n      token_secret: opts.token_secret,\n      allow_unauthenticated: opts.allow_unauthenticated,\n      allow_anonymous: opts.allow_anonymous,\n      success_redirect: opts.auth_redirect,\n      failure_redirect: opts.auth_redirect,\n    },\n    rdb_host: opts.rdb_host,\n    rdb_port: opts.rdb_port,\n    rdb_user: opts.rdb_user || null,\n    rdb_password: opts.rdb_password || null,\n    rdb_timeout: opts.rdb_timeout || null,\n  });\n\n// `interruptor` is meant for use by tests to stop the server without relying on SIGINT\nconst run = (args, interruptor) => {\n  let opts, http_servers, hz_server, rdb_server;\n  const old_log_level = logger.level;\n\n  const cleanup = () => {\n    logger.level = old_log_level;\n\n    return Promise.all([\n      hz_server ? hz_server.close() : Promise.resolve(),\n      rdb_server ? rdb_server.close() : Promise.resolve(),\n      http_servers ? Promise.all(http_servers.map((s) =>\n        new Promise((resolve) => s.close(resolve)))) : Promise.resolve(),\n    ]);\n  };\n\n  interrupt.on_interrupt(() => cleanup());\n\n  return Promise.resolve().then(() => {\n    opts = processConfig(parseArguments(args));\n    logger.level = opts.debug ? 'debug' : 'warn';\n\n    if (!opts.secure && opts.auth && Array.from(Object.keys(opts.auth)).length > 0) {\n      logger.warn('Authentication requires that the server be accessible via HTTPS. ' +\n                  'Either specify \"secure=true\" or use a reverse proxy.');\n    }\n\n    change_to_project_dir(opts.project_path);\n\n    if (opts.secure) {\n      return create_secure_servers(opts);\n    } else {\n      return create_insecure_servers(opts);\n    }\n  }).then((servers) => {\n    http_servers = servers;\n\n    if (opts.start_rethinkdb) {\n      return start_rdb_server().then((server) => {\n        rdb_server = server;\n\n        // Don't need to check for host, always localhost.\n        opts.rdb_host = 'localhost';\n        opts.rdb_port = server.driver_port;\n\n        console.log('RethinkDB');\n        console.log(`   ├── Admin interface: http://localhost:${server.http_port}`);\n        console.log(`   └── Drivers can connect to port ${server.driver_port}`);\n      });\n    }\n  }).then(() => {\n    // Ensure schema from schema.toml file is set\n    if (opts.schema_file) {\n      console.log(`Ensuring schema \"${opts.schema_file}\" is applied`);\n      try {\n        fs.accessAsync(opts.schema_file, fs.R_OK | fs.F_OK);\n      } catch (e) {\n        console.error(\n          chalk.yellow.bold('No .hz/schema.toml file found'));\n        return;\n      }\n      const schemaOptions = schema.processApplyConfig({\n        project_name: opts.project_name,\n        schema_file: opts.schema_file,\n        start_rethinkdb: false,\n        connect: `${opts.rdb_host}:${opts.rdb_port}`,\n        update: true,\n        force: false,\n      });\n      return schema.runApplyCommand(schemaOptions);\n    }\n  }).then(() => {\n    console.log('Starting Horizon...');\n    hz_server = start_horizon_server(http_servers, opts);\n\n    return new Promise((resolve, reject) => {\n      const timeoutObject = setTimeout(() => {\n        reject(new Error('Horizon failed to start after 30 seconds.\\n' +\n                         'Try running hz serve again with the --debug flag'));\n      }, TIMEOUT_30_SECONDS);\n\n      hz_server.ready().then(() => {\n        clearTimeout(timeoutObject);\n        console.log(chalk.green.bold('🌄 Horizon ready for connections'));\n        resolve(hz_server);\n      }).catch(reject);\n    });\n  }).then(() => {\n    if (opts.auth) {\n      for (const name in opts.auth) {\n        const provider = horizon_server.auth[name];\n        if (!provider) {\n          throw new Error(`Unrecognized auth provider \"${name}\"`);\n        }\n        hz_server.add_auth_provider(provider,\n                                    Object.assign({}, { path: name }, opts.auth[name]));\n      }\n    }\n  }).then(() => {\n    // Automatically open up index.html in the `dist` directory only if\n    //  `--open` flag specified and an index.html exists in the directory.\n    if (opts.open && opts.serve_static) {\n      try {\n        // Check if index.html exists and readable in serve static_static directory\n        fs.accessSync(`${opts.serve_static}/index.html`, fs.R_OK | fs.F_OK);\n        // Determine scheme from options\n        const scheme = opts.secure ? 'https://' : 'http://';\n        // Open up index.html in default browser\n        console.log('Attempting open of index.html in default browser');\n        open(`${scheme}${opts.bind}:${opts.port}/index.html`);\n      } catch (open_err) {\n        console.log(chalk.red('Error occurred while trying to open ' +\n                              `${opts.serve_static}/index.html`));\n        console.log(open_err);\n      }\n    }\n\n    return Promise.race([\n      hz_server._interruptor.catch(() => { }),\n      interruptor ? interruptor.catch(() => { }) : new Promise(() => { }),\n    ]);\n  }).then(cleanup).catch((err) => cleanup().then(() => { throw err; }));\n};\n\nmodule.exports = {\n  run,\n  description: 'Serve a Horizon app',\n  parseArguments,\n  processConfig,\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/config.js":"'use strict';\n\nconst parse_yes_no_option = require('./parse_yes_no_option');\nconst NiceError = require('./nice_error.js');\n\nconst fs = require('fs');\nconst url = require('url');\n\nconst toml = require('toml');\nconst chalk = require('chalk');\n\nconst default_config_file = '.hz/config.toml';\nconst default_secrets_file = '.hz/secrets.toml';\nconst default_rdb_port = 28015;\n\nconst make_default_options = () => ({\n  config: null,\n  debug: false,\n  // Default to current directory for path\n  project_path: '.',\n  // Default to current directory name for project name\n  project_name: null,\n\n  bind: [ 'localhost' ],\n  port: 8181,\n\n  start_rethinkdb: false,\n  serve_static: null,\n  open: false,\n\n  secure: true,\n  permissions: true,\n  key_file: './horizon-key.pem',\n  cert_file: './horizon-cert.pem',\n  schema_file: null,\n\n  auto_create_collection: false,\n  auto_create_index: false,\n\n  rdb_host: null,\n  rdb_port: null,\n  rdb_user: null,\n  rdb_password: null,\n  rdb_timeout: null,\n\n  token_secret: null,\n  allow_anonymous: false,\n  allow_unauthenticated: false,\n  auth_redirect: '/',\n  access_control_allow_origin: '',\n\n  auth: { },\n});\n\nconst default_options = make_default_options();\n\nconst yes_no_options = [ 'debug',\n                         'secure',\n                         'permissions',\n                         'start_rethinkdb',\n                         'auto_create_index',\n                         'auto_create_collection',\n                         'allow_unauthenticated',\n                         'allow_anonymous' ];\n\nconst parse_connect = (connect, config) => {\n  // support rethinkdb:// style connection uri strings\n  // expects rethinkdb://host:port` at a minimum but can optionally take a user:pass and db\n  // e.g. rethinkdb://user:pass@host:port/db\n  const rdb_uri = url.parse(connect);\n  if (rdb_uri.protocol === 'rethinkdb:') {\n    if (rdb_uri.hostname) {\n      config.rdb_host = rdb_uri.hostname;\n      config.rdb_port = rdb_uri.port || default_rdb_port;\n\n      // check for user/pass\n      if (rdb_uri.auth) {\n        const user_pass = rdb_uri.auth.split(':');\n        config.rdb_user = user_pass[0];\n        config.rdb_password = user_pass[1];\n      }\n\n      // set the project name based on the db\n      if (rdb_uri.path && rdb_uri.path.replace('/', '') !== '') {\n        config.project_name = rdb_uri.path.replace('/', '');\n      }\n    } else {\n      throw new Error(`Expected --connect rethinkdb://HOST, but found \"${connect}\".`);\n    }\n  } else {\n    // support legacy HOST:PORT connection strings\n    const host_port = connect.split(':');\n    if (host_port.length === 1) {\n      config.rdb_host = host_port[0];\n      config.rdb_port = default_rdb_port;\n    } else if (host_port.length === 2) {\n      config.rdb_host = host_port[0];\n      config.rdb_port = parseInt(host_port[1]);\n      if (isNaN(config.rdb_port) || config.rdb_port < 0 || config.rdb_port > 65535) {\n        throw new Error(`Invalid port: \"${host_port[1]}\".`);\n      }\n    } else {\n      throw new Error(`Expected --connect HOST:PORT, but found \"${connect}\".`);\n    }\n  }\n};\n\nconst read_from_config_file = (project_path) => {\n  const config = { auth: { } };\n\n  let fileData, configFilename, fileConfig;\n\n  if (project_path) {\n    configFilename = `${project_path}/${default_config_file}`;\n  } else {\n    configFilename = default_config_file;\n  }\n\n  try {\n    fileData = fs.readFileSync(configFilename);\n  } catch (err) {\n    return config;\n  }\n\n  try {\n    fileConfig = toml.parse(fileData);\n  } catch (e) {\n    if (e.name === 'SyntaxError') {\n      throw new NiceError(\n        `There was a syntax error when parsing ${configFilename}`, {\n          description: `Something was wrong with the format of \\\n${configFilename}, causing it not be a valid TOML file.`,\n          src: {\n            filename: configFilename,\n            contents: fileData,\n            line: e.line,\n            column: e.column,\n          },\n          suggestions: [\n            'Check that all strings values have quotes around them',\n            'Check that key/val pairs use equals and not colons',\n            'See https://github.com/toml-lang/toml#user-content-spec',\n          ],\n        });\n    } else {\n      throw e;\n    }\n  }\n  for (const field in fileConfig) {\n    if (field === 'connect') {\n      parse_connect(fileConfig.connect, config);\n    } else if (yes_no_options.indexOf(field) !== -1) {\n      config[field] = parse_yes_no_option(fileConfig[field], field);\n    } else if (default_options[field] !== undefined) {\n      config[field] = fileConfig[field];\n    } else {\n      throw new Error(`Unknown config parameter: \"${field}\".`);\n    }\n  }\n  return config;\n};\n\nconst read_from_secrets_file = (projectPath) => {\n  const config = { auth: { } };\n\n  let fileData, secretsFilename;\n\n  if (projectPath) {\n    secretsFilename = `${projectPath}/${default_secrets_file}`;\n  } else {\n    secretsFilename = default_secrets_file;\n  }\n\n  try {\n    fileData = fs.readFileSync(secretsFilename);\n  } catch (err) {\n    return config;\n  }\n\n  const fileConfig = toml.parse(fileData);\n  for (const field in fileConfig) {\n    if (field === 'connect') {\n      parse_connect(fileConfig.connect, config);\n    } else if (yes_no_options.indexOf(field) !== -1) {\n      config[field] = parse_yes_no_option(fileConfig[field], field);\n    } else if (default_options[field] !== undefined) {\n      config[field] = fileConfig[field];\n    } else {\n      throw new Error(`Unknown config parameter: \"${field}\".`);\n    }\n  }\n\n  return config;\n};\n\nconst env_regex = /^HZ_([A-Z]+([_]?[A-Z]+)*)$/;\nconst read_from_env = () => {\n  const config = { auth: { } };\n  for (const env_var in process.env) {\n    const matches = env_regex.exec(env_var);\n    if (matches && matches[1]) {\n      const destVarName = matches[1].toLowerCase();\n      const varPath = destVarName.split('_');\n      const value = process.env[env_var];\n\n      if (destVarName === 'connect') {\n        parse_connect(value, config);\n      } else if (destVarName === 'bind') {\n        config[destVarName] = value.split(',');\n      } else if (varPath[0] === 'auth') {\n        if (varPath.length !== 3) {\n          console.log(`Ignoring malformed Horizon environment variable: \"${env_var}\", ` +\n                      'should be HZ_AUTH_{PROVIDER}_{OPTION}.');\n        } else {\n          config.auth[varPath[1]] = config.auth[varPath[1]] || { };\n          config.auth[varPath[1]][varPath[2]] = value;\n        }\n      } else if (yes_no_options.indexOf(destVarName) !== -1) {\n        config[destVarName] = parse_yes_no_option(value, destVarName);\n      } else if (default_options[destVarName] !== undefined) {\n        config[destVarName] = value;\n      }\n    }\n  }\n\n  return config;\n};\n\n// Handles reading configuration from the parsed flags\nconst read_from_flags = (parsed) => {\n  const config = { auth: { } };\n\n  // Dev mode\n  if (parsed.dev) {\n    config.access_control_allow_origin = '*';\n    config.allow_unauthenticated = true;\n    config.allow_anonymous = true;\n    config.secure = false;\n    config.permissions = false;\n    config.start_rethinkdb = true;\n    config.auto_create_collection = true;\n    config.auto_create_index = true;\n    config.serve_static = 'dist';\n    config._dev_flag_used = true;\n\n    if (parsed.start_rethinkdb === null || parsed.start_rethinkdb === undefined) {\n      config._start_rethinkdb_implicit = true;\n    }\n  }\n\n  for (const key in parsed) {\n    if (key === 'auth' && parsed.auth != null) {\n      // Auth options\n      parsed.auth.forEach((auth_options) => {\n        const params = auth_options.split(',');\n        if (params.length !== 3) {\n          throw new Error(`Expected --auth PROVIDER,ID,SECRET, but found \"${auth_options}\"`);\n        }\n        config.auth[params[0]] = { id: params[1], secret: params[2] };\n      });\n    } else if (key === 'connect' && parsed.connect != null) {\n      // Normalize RethinkDB connection options\n      parse_connect(parsed.connect, config);\n    } else if (yes_no_options.indexOf(key) !== -1 && parsed[key] != null) {\n      // Simple 'yes' or 'no' (or 'true' or 'false') flags\n      config[key] = parse_yes_no_option(parsed[key], key);\n    } else if (parsed[key] != null) {\n      config[key] = parsed[key];\n    }\n  }\n\n  return config;\n};\n\nconst merge_options = (old_options, new_options) => {\n  // Disable start_rethinkdb if it was enabled by dev mode but we already have a host\n  if (new_options._start_rethinkdb_implicit) {\n    if (old_options.rdb_host) {\n      delete new_options.start_rethinkdb;\n    }\n  } else if (new_options.start_rethinkdb && new_options.rdb_host) {\n    throw new Error('Cannot provide both --start-rethinkdb and --connect.');\n  }\n\n  for (const key in new_options) {\n    if (key === 'rdb_host') {\n      old_options.start_rethinkdb = false;\n    }\n\n    if (key === 'auth') {\n      for (const provider in new_options.auth) {\n        old_options.auth[provider] = old_options.auth[provider] || { };\n        for (const field in new_options.auth[provider]) {\n          old_options.auth[provider][field] = new_options.auth[provider][field];\n        }\n      }\n    } else {\n      old_options[key] = new_options[key];\n    }\n  }\n\n  return old_options;\n};\n\nmodule.exports = {\n  default_config_file,\n  default_secrets_file,\n  default_options: make_default_options,\n  read_from_config_file,\n  read_from_secrets_file,\n  read_from_env,\n  read_from_flags,\n  merge_options,\n  parse_connect,\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/parse_yes_no_option.js":"'use strict';\n\nmodule.exports = (value, option_name) => {\n  if (value !== undefined && value !== null) {\n    const lower = value.toLowerCase ? value.toLowerCase() : value;\n    if (lower === true || lower === 'true' || lower === 'yes') {\n      return true;\n    } else if (lower === false || lower === 'false' || lower === 'no') {\n      return false;\n    }\n    throw new Error(`Unexpected value \"${option_name}=${value}\", should be yes or no.`);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/nice_error.js":"'use strict';\n\n/*\nA nice error type that allows you to associate a longer description, a\nsource file and suggestions with it.\n*/\n\nconst chalk = require('chalk');\n\nclass NiceError extends Error {\n  constructor(message, options) {\n    super(message);\n    const opts = options || {};\n    this.description = opts.description || null;\n    this.suggestions = opts.suggestions || null;\n    // TODO: maybe allow multiple source locations and spans of text\n    // instead of a single column offset\n    this.src = (opts.src) ? Object.assign({}, opts.src) : null;\n  }\n  toString() {\n    return this.message;\n  }\n\n  niceString(options) {\n    const opts = options || {};\n    const cSize = opts.contextSize != null ? opts.contextSize : 2;\n    const results = [ this.message ];\n    if (this.description) {\n      results.push('', this.description);\n    }\n    if (this.src != null) {\n      const formattedSrc = NiceError._formatContext(\n        this.src.contents,\n        this.src.line,\n        this.src.column,\n        cSize\n      );\n      if (formattedSrc.length > 0) {\n        results.push(`\\nIn ${this.src.filename}, ` +\n                     `line ${this.src.line}, ` +\n                     `column ${this.src.column}:`);\n        results.push.apply(results, formattedSrc);\n      }\n    }\n    if (this.suggestions) {\n      results.push(\n        '', // extra newline before suggestions\n        chalk.red(\n          this.suggestions.length > 1 ? 'Suggestions:' : 'Suggestion:'));\n      results.push.apply(\n        results, this.suggestions.map((note) => `  ➤ ${note}`));\n    }\n    results.push(''); // push a final newline on\n    return results.join('\\n');\n  }\n\n  static _sourceLine(ln) {\n    return `${chalk.blue(`${ln.line}:`)} ${chalk.white(ln.src)}`;\n  }\n\n  static _extractContext(sourceContents, line, contextSize) {\n    const lines = sourceContents.toString().split('\\n');\n    const minLine = Math.max(line - contextSize - 1, 0);\n    const maxLine = Math.min(line + contextSize, lines.length);\n    if (line > lines.length) {\n      return [];\n    } else {\n      return lines.slice(minLine, maxLine).map((src, i) => ({\n        line: i + minLine + 1,\n        src,\n      }));\n    }\n  }\n\n  static _formatContext(sourceContents, line, col, contextSize) {\n    return this._extractContext(sourceContents, line, contextSize)\n      .map((srcLine) => {\n        let formatted = this._sourceLine(srcLine);\n        if (srcLine.line === line) {\n          const prefix = `${line}: `;\n          formatted +=\n            `\\n${' '.repeat(prefix.length + col - 1)}${chalk.green('^')}`;\n        }\n        return formatted;\n      });\n  }\n\n}\n\nmodule.exports = NiceError;\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/start_rdb_server.js":"'use strict';\n\nconst each_line_in_pipe = require('./each_line_in_pipe');\nconst horizon_server = require('@horizon/server');\n\nconst execSync = require('child_process').execSync;\nconst spawn = require('child_process').spawn;\nconst hasbinSync = require('hasbin').sync;\n\nconst defaultDatadir = 'rethinkdb_data';\n\nconst infoLevelLog = (msg) => /^Running/.test(msg) || /^Listening/.test(msg);\n\nconst r = horizon_server.r;\nconst logger = horizon_server.logger;\nconst version_check = horizon_server.utils.rethinkdb_version_check;\n\nclass RethinkdbServer {\n  constructor(options) {\n    const quiet = Boolean(options.quiet);\n    const bind = options.bind || [ '127.0.0.1' ];\n    const dataDir = options.dataDir || defaultDatadir;\n    const driverPort = options.rdbPort;\n    const httpPort = options.rdbHttpPort;\n    const cacheSize = options.cacheSize || 200;\n\n    // Check if `rethinkdb` in PATH\n    if (!hasbinSync('rethinkdb')) {\n      throw new Error('`rethinkdb` not found in $PATH, please install RethinkDB.');\n    }\n\n    // Check if RethinkDB is sufficient version for Horizon\n    version_check(execSync('rethinkdb --version', { timeout: 5000 }).toString());\n\n    const args = [ '--http-port', String(httpPort || 0),\n                   '--cluster-port', '0',\n                   '--driver-port', String(driverPort || 0),\n                   '--cache-size', String(cacheSize),\n                   '--directory', dataDir,\n                   '--no-update-check' ];\n    bind.forEach((host) => args.push('--bind', host));\n\n    this.proc = spawn('rethinkdb', args);\n\n    this.ready_promise = new Promise((resolve, reject) => {\n      this.proc.once('error', reject);\n      this.proc.once('exit', (exit_code) => {\n        if (exit_code !== 0) {\n          reject(new Error(`RethinkDB process terminated with error code ${exit_code}.`));\n        }\n      });\n\n      process.on('exit', () => {\n        if (this.proc.exitCode === null) {\n          logger.error('Unclean shutdown - killing RethinkDB child process');\n          this.proc.kill('SIGKILL');\n        }\n      });\n\n      const maybe_resolve = () => {\n        // Once we have both ports determined, callback with all settings.\n        if (this.http_port !== undefined &&\n            this.driver_port !== undefined) {\n          resolve(this);\n        }\n      };\n\n      each_line_in_pipe(this.proc.stdout, (line) => {\n        if (!quiet) {\n          if (infoLevelLog(line)) {\n            logger.info('RethinkDB', line);\n          } else {\n            logger.debug('RethinkDB stdout:', line);\n          }\n        }\n        if (this.driver_port === undefined) {\n          const matches = line.match(\n              /^Listening for client driver connections on port (\\d+)$/);\n          if (matches !== null && matches.length === 2) {\n            this.driver_port = parseInt(matches[1]);\n            maybe_resolve();\n          }\n        }\n        if (this.http_port === undefined) {\n          const matches = line.match(\n              /^Listening for administrative HTTP connections on port (\\d+)$/);\n          if (matches !== null && matches.length === 2) {\n            this.http_port = parseInt(matches[1]);\n            maybe_resolve();\n          }\n        }\n      });\n\n      each_line_in_pipe(this.proc.stderr, (line) =>\n                        logger.error(`rethinkdb stderr: ${line}`));\n    });\n  }\n\n  ready() {\n    return this.ready_promise;\n  }\n\n  // This is only used by tests - cli commands use a more generic method as\n  // the database may be launched elsewhere.\n  connect() {\n    return r.connect({ host: 'localhost', port: this.driver_port });\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      if (this.proc.exitCode !== null) {\n        resolve();\n      } else {\n        this.proc.kill('SIGTERM');\n\n        this.proc.once('exit', () => {\n          resolve();\n        });\n\n        setTimeout(() => {\n          this.proc.kill('SIGKILL');\n          resolve();\n        }, 20000).unref();\n      }\n    });\n  }\n}\n\n// start_rdb_server\n// Options:\n// quiet: boolean, suppresses rethinkdb log messages\n// bind: array of ip addresses to bind to, or 'all'\n// dataDir: name of rethinkdb data directory. Defaults to `rethinkdb_data`\n// driverPort: port number for rethinkdb driver connections. Auto-assigned by default.\n// httpPort: port number for webui. Auto-assigned by default.\n// cacheSize: cacheSize to give to rethinkdb in MB. Default 200.\nmodule.exports = (options) => new RethinkdbServer(options || { }).ready();\nmodule.exports.r = r;\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/each_line_in_pipe.js":"'use strict';\n\nmodule.exports = (pipe, callback) => {\n  let buffer = '';\n  pipe.on('data', (data) => {\n    buffer += data.toString();\n\n    let endline_pos = buffer.indexOf('\\n');\n    while (endline_pos !== -1) {\n      const line = buffer.slice(0, endline_pos);\n      buffer = buffer.slice(endline_pos + 1);\n      callback(line);\n      endline_pos = buffer.indexOf('\\n');\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/change_to_project_dir.js":"'use strict';\n\nconst is_directory = require('./is_directory');\n\nmodule.exports = (project_path) => {\n  if (is_directory(project_path)) {\n    process.chdir(project_path);\n  } else {\n    throw new Error(`${project_path} is not a directory`);\n  }\n  if (!is_directory('.hz')) {\n    const nice_path = (project_path === '.' ? 'this directory' : project_path);\n    throw new Error(`${nice_path} doesn't contain an .hz directory`);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/is_directory.js":"'use strict';\n\nconst path = require('path');\nconst fs = require('fs');\n\nmodule.exports = (dirname) => {\n  try {\n    return fs.statSync(path.resolve(dirname)).isDirectory();\n  } catch (e) {\n    return false;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/interrupt.js":"'use strict';\n\nconst handlers = [ ];\n\nconst on_interrupt = (cb) => {\n  handlers.push(cb);\n};\n\nconst run_handlers = () => {\n  if (handlers.length > 0) {\n    return handlers.shift()().then(() => run_handlers);\n  }\n};\n\nconst interrupt = () => {\n  process.removeAllListeners('SIGTERM');\n  process.removeAllListeners('SIGINT');\n  process.on('SIGTERM', () => process.exit(1));\n  process.on('SIGINT', () => process.exit(1));\n\n  return run_handlers();\n};\n\nprocess.on('SIGTERM', interrupt);\nprocess.on('SIGINT', interrupt);\n\nmodule.exports = { on_interrupt, interrupt };\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/schema.js":"'use strict';\n\nconst horizon_server = require('@horizon/server');\nconst horizon_index = require('@horizon/server/src/metadata/index');\nconst horizon_metadata = require('@horizon/server/src/metadata/metadata');\n\nconst config = require('./utils/config');\nconst interrupt = require('./utils/interrupt');\nconst start_rdb_server = require('./utils/start_rdb_server');\nconst parse_yes_no_option = require('./utils/parse_yes_no_option');\nconst change_to_project_dir = require('./utils/change_to_project_dir');\nconst initialize_joi = require('./utils/initialize_joi');\n\nconst fs = require('fs');\nconst Joi = require('joi');\nconst path = require('path');\n\nconst argparse = require('argparse');\nconst toml = require('toml');\n\nconst r = horizon_server.r;\nconst create_collection = horizon_metadata.create_collection;\nconst initialize_metadata = horizon_metadata.initialize_metadata;\n\ninitialize_joi(Joi);\n\nconst parseArguments = (args) => {\n  const parser = new argparse.ArgumentParser({ prog: 'hz schema' });\n\n  const subparsers = parser.addSubparsers({\n    title: 'subcommands',\n    dest: 'subcommand_name',\n  });\n\n  const apply = subparsers.addParser('apply', { addHelp: true });\n  const save = subparsers.addParser('save', { addHelp: true });\n\n  // Set options shared between both subcommands\n  [ apply, save ].map((subcmd) => {\n    subcmd.addArgument([ 'project_path' ],\n      { type: 'string', nargs: '?',\n        help: 'Change to this directory before serving' });\n\n    subcmd.addArgument([ '--project-name', '-n' ],\n      { type: 'string', action: 'store', metavar: 'NAME',\n        help: 'Name of the Horizon Project server' });\n\n    subcmd.addArgument([ '--connect', '-c' ],\n      { type: 'string', metavar: 'HOST:PORT',\n        help: 'Host and port of the RethinkDB server to connect to.' });\n\n    subcmd.addArgument([ '--rdb-timeout' ],\n      { type: 'int', metavar: 'TIMEOUT',\n        help: 'Timeout period in seconds for the RethinkDB connection to be opened' });\n\n    subcmd.addArgument([ '--rdb-user' ],\n      { type: 'string', metavar: 'USER',\n        help: 'RethinkDB User' });\n\n    subcmd.addArgument([ '--rdb-password' ],\n      { type: 'string', metavar: 'PASSWORD',\n        help: 'RethinkDB Password' });\n\n    subcmd.addArgument([ '--start-rethinkdb' ],\n      { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n        help: 'Start up a RethinkDB server in the current directory' });\n\n    subcmd.addArgument([ '--debug' ],\n      { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n        help: 'Enable debug logging.' });\n  });\n\n  // Options exclusive to HZ SCHEMA APPLY\n  apply.addArgument([ '--update' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Only add new items and update existing, no removal.' });\n\n  apply.addArgument([ '--force' ],\n    { type: 'string', metavar: 'yes|no', constant: 'yes', nargs: '?',\n      help: 'Allow removal of existing collections.' });\n\n  apply.addArgument([ 'schema_file' ],\n    { type: 'string', metavar: 'SCHEMA_FILE_PATH',\n      help: 'File to get the horizon schema from, use \"-\" for stdin.' });\n\n  // Options exclusive to HZ SCHEMA SAVE\n  save.addArgument([ '--out-file', '-o' ],\n    { type: 'string', metavar: 'PATH', defaultValue: '.hz/schema.toml',\n      help: 'File to write the horizon schema to, defaults to .hz/schema.toml.' });\n\n  return parser.parseArgs(args);\n};\n\nconst schema_schema = Joi.object().unknown(false).keys({\n  collections: Joi.object().unknown(true).pattern(/.*/,\n    Joi.object().unknown(false).keys({\n      indexes: Joi.array().items(\n        Joi.alternatives(\n          Joi.string(),\n          Joi.object().unknown(false).keys({\n            fields: Joi.array().items(Joi.array().items(Joi.string())).required(),\n          })\n        )\n      ).optional().default([ ]),\n    })\n  ).optional().default({ }),\n  groups: Joi.object().unknown(true).pattern(/.*/,\n    Joi.object().keys({\n      rules: Joi.object().unknown(true).pattern(/.*/,\n        Joi.object().unknown(false).keys({\n          template: Joi.string().required(),\n          validator: Joi.string().optional(),\n        })\n      ).optional().default({ }),\n    })\n  ).optional().default({ }),\n});\n\n// Preserved for interpreting old schemas\nconst v1_0_name_to_fields = (name) => {\n  let escaped = false;\n  let field = '';\n  const fields = [ ];\n  for (const c of name) {\n    if (escaped) {\n      if (c !== '\\\\' && c !== '_') {\n        throw new Error(`Unexpected index name: \"${name}\"`);\n      }\n      escaped = false;\n      field += c;\n    } else if (c === '\\\\') {\n      escaped = true;\n    } else if (c === '_') {\n      fields.push(field);\n      field = '';\n    } else {\n      field += c;\n    }\n  }\n  if (escaped) {\n    throw new Error(`Unexpected index name: \"${name}\"`);\n  }\n  fields.push([ field ]);\n  return fields;\n};\n\nconst parse_schema = (schema_toml) => {\n  const parsed = Joi.validate(toml.parse(schema_toml), schema_schema);\n  const schema = parsed.value;\n\n  if (parsed.error) {\n    throw parsed.error;\n  }\n\n  const collections = [ ];\n  for (const name in schema.collections) {\n    collections.push({\n      id: name,\n      indexes: schema.collections[name].indexes.map((index) => {\n        if (typeof index === 'string') {\n          return { fields: v1_0_name_to_fields(index), multi: false, geo: false };\n        } else {\n          return { fields: index.fields, multi: false, geo: false };\n        }\n      }),\n    });\n  }\n\n  // Make sure the 'users' collection is present, as some things depend on\n  // its existence.\n  if (!schema.collections || !schema.collections.users) {\n    collections.push({ id: 'users', indexes: [ ] });\n  }\n\n  const groups = [ ];\n  for (const name in schema.groups) {\n    groups.push(Object.assign({ id: name }, schema.groups[name]));\n  }\n\n  return { groups, collections };\n};\n\nconst processApplyConfig = (parsed) => {\n  let options, in_file;\n\n  options = config.default_options();\n  options = config.merge_options(options,\n    config.read_from_config_file(parsed.project_path));\n  options = config.merge_options(options, config.read_from_env());\n  options = config.merge_options(options, config.read_from_flags(parsed));\n\n  if (parsed.schema_file === '-') {\n    in_file = process.stdin;\n  } else {\n    in_file = fs.createReadStream(parsed.schema_file, { flags: 'r' });\n  }\n\n  if (options.project_name === null) {\n    options.project_name = path.basename(path.resolve(options.project_path));\n  }\n\n  return {\n    subcommand_name: 'apply',\n    start_rethinkdb: options.start_rethinkdb,\n    rdb_host: options.rdb_host,\n    rdb_port: options.rdb_port,\n    project_name: options.project_name,\n    project_path: options.project_path,\n    debug: options.debug,\n    update: parse_yes_no_option(parsed.update),\n    force: parse_yes_no_option(parsed.force),\n    in_file,\n  };\n};\n\nconst processSaveConfig = (parsed) => {\n  let options, out_file;\n\n  options = config.default_options();\n  options.start_rethinkdb = true;\n\n  options = config.merge_options(options,\n    config.read_from_config_file(parsed.project_path));\n  options = config.merge_options(options, config.read_from_env());\n  options = config.merge_options(options, config.read_from_flags(parsed));\n\n  if (parsed.out_file === '-') {\n    out_file = process.stdout;\n  } else {\n    out_file = parsed.out_file;\n  }\n\n  if (options.project_name === null) {\n    options.project_name = path.basename(path.resolve(options.project_path));\n  }\n\n  return {\n    subcommand_name: 'save',\n    start_rethinkdb: options.start_rethinkdb,\n    rdb_host: options.rdb_host,\n    rdb_port: options.rdb_port,\n    project_name: options.project_name,\n    project_path: options.project_path,\n    debug: options.debug,\n    out_file,\n  };\n};\n\nconst schema_to_toml = (collections, groups) => {\n  const res = [ '# This is a TOML document' ];\n\n  for (const c of collections) {\n    res.push('');\n    res.push(`[collections.${c.id}]`);\n    c.indexes.forEach((index) => {\n      const info = horizon_index.name_to_info(index);\n      res.push(`[[collections.${c.id}.indexes]]`);\n      res.push(`fields = ${JSON.stringify(info.fields)}`);\n    });\n  }\n\n  for (const g of groups) {\n    res.push('');\n    res.push(`[groups.${g.id}]`);\n    if (g.rules) {\n      for (const key in g.rules) {\n        const template = g.rules[key].template;\n        const validator = g.rules[key].validator;\n        res.push(`[groups.${g.id}.rules.${key}]`);\n        res.push(`template = ${JSON.stringify(template)}`);\n        if (validator) {\n          res.push(`validator = ${JSON.stringify(validator)}`);\n        }\n      }\n    }\n  }\n\n  res.push('');\n  return res.join('\\n');\n};\n\nconst runApplyCommand = (options) => {\n  let conn, schema, rdb_server;\n  let obsolete_collections = [ ];\n  const db = options.project_name;\n\n  const cleanup = () =>\n    Promise.all([\n      conn ? conn.close() : Promise.resolve(),\n      rdb_server ? rdb_server.close() : Promise.resolve(),\n    ]);\n\n  interrupt.on_interrupt(() => cleanup());\n\n  return Promise.resolve().then(() => {\n    if (options.start_rethinkdb) {\n      change_to_project_dir(options.project_path);\n    }\n\n    return new Promise((resolve, reject) => {\n      let schema_toml = '';\n      options.in_file.on('data', (buffer) => (schema_toml += buffer));\n      options.in_file.on('end', () => resolve(schema_toml));\n      options.in_file.on('error', reject);\n    });\n  }).then((schema_toml) => {\n    schema = parse_schema(schema_toml);\n\n    if (options.start_rethinkdb) {\n      return start_rdb_server({ quiet: !options.debug }).then((server) => {\n        rdb_server = server;\n        options.rdb_host = 'localhost';\n        options.rdb_port = server.driver_port;\n      });\n    }\n  }).then(() =>\n    r.connect({ host: options.rdb_host,\n                port: options.rdb_port,\n                user: options.rdb_user,\n                password: options.rdb_password,\n                timeout: options.rdb_timeout })\n  ).then((rdb_conn) => {\n    conn = rdb_conn;\n    return initialize_metadata(db, conn);\n  }).then((initialization_result) => {\n    if (initialization_result.tables_created) {\n      console.log('Initialized new application metadata.');\n    }\n    // Wait for metadata tables to be writable\n    return r.expr([ 'hz_collections', 'hz_groups' ])\n      .forEach((table) =>\n        r.db(db).table(table)\n          .wait({ waitFor: 'ready_for_writes', timeout: 30 }))\n      .run(conn);\n  }).then(() => {\n    // Error if any collections will be removed\n    if (!options.update) {\n      return r.db(db).table('hz_collections')\n        .filter((row) => row('id').match('^hz_').not())\n        .getField('id')\n        .coerceTo('array')\n        .setDifference(schema.collections.map((c) => c.id))\n        .run(conn)\n        .then((res) => {\n          if (!options.force && res.length > 0) {\n            throw new Error('Run with \"--force\" to continue.\\n' +\n                            'These collections would be removed along with their data:\\n' +\n                            `${res.join(', ')}`);\n          }\n          obsolete_collections = res;\n        });\n    }\n  }).then(() => {\n    if (options.update) {\n      // Update groups\n      return Promise.all(schema.groups.map((group) => {\n        const literal_group = JSON.parse(JSON.stringify(group));\n        Object.keys(literal_group.rules).forEach((key) => {\n          literal_group.rules[key] = r.literal(literal_group.rules[key]);\n        });\n\n        return r.db(db).table('hz_groups')\n          .get(group.id).replace((old_row) =>\n            r.branch(old_row.eq(null),\n                     group,\n                     old_row.merge(literal_group)))\n          .run(conn).then((res) => {\n            if (res.errors) {\n              throw new Error(`Failed to update group: ${res.first_error}`);\n            }\n          });\n      }));\n    } else {\n      // Replace and remove groups\n      const groups_obj = { };\n      schema.groups.forEach((g) => { groups_obj[g.id] = g; });\n\n      return Promise.all([\n        r.expr(groups_obj).do((groups) =>\n          r.db(db).table('hz_groups')\n            .replace((old_row) =>\n              r.branch(groups.hasFields(old_row('id')),\n                       old_row,\n                       null))\n          ).run(conn).then((res) => {\n            if (res.errors) {\n              throw new Error(`Failed to write groups: ${res.first_error}`);\n            }\n          }),\n        r.db(db).table('hz_groups')\n          .insert(schema.groups, { conflict: 'replace' })\n          .run(conn).then((res) => {\n            if (res.errors) {\n              throw new Error(`Failed to write groups: ${res.first_error}`);\n            }\n          }),\n      ]);\n    }\n  }).then(() => {\n    // Ensure all collections exist and remove any obsolete collections\n    const promises = [ ];\n    for (const c of schema.collections) {\n      promises.push(\n        create_collection(db, c.id, conn).then((res) => {\n          if (res.error) {\n            throw new Error(res.error);\n          }\n        }));\n    }\n\n    for (const c of obsolete_collections) {\n      promises.push(\n        r.db(db)\n          .table('hz_collections')\n          .get(c)\n          .delete({ returnChanges: 'always' })('changes')(0)\n          .do((res) =>\n            r.branch(res.hasFields('error'),\n                     res,\n                     res('old_val').eq(null),\n                     res,\n                     r.db(db).tableDrop(res('old_val')('id')).do(() => res)))\n          .run(conn).then((res) => {\n            if (res.error) {\n              throw new Error(res.error);\n            }\n          }));\n    }\n\n    return Promise.all(promises);\n  }).then(() => {\n    const promises = [ ];\n\n    // Ensure all indexes exist\n    for (const c of schema.collections) {\n      for (const info of c.indexes) {\n        const name = horizon_index.info_to_name(info);\n        promises.push(\n          r.branch(r.db(db).table(c.id).indexList().contains(name), { },\n                   r.db(db).table(c.id).indexCreate(name, horizon_index.info_to_reql(info),\n                     { geo: Boolean(info.geo), multi: (info.multi !== false) }))\n            .run(conn)\n            .then((res) => {\n              if (res.errors) {\n                throw new Error(`Failed to create index ${name} ` +\n                                `on collection ${c.id}: ${res.first_error}`);\n              }\n            }));\n      }\n    }\n\n    // Remove obsolete indexes\n    if (!options.update) {\n      for (const c of schema.collections) {\n        const names = c.indexes.map(horizon_index.info_to_name);\n        promises.push(\n          r.db(db).table(c.id).indexList().filter((name) => name.match('^hz_'))\n            .setDifference(names)\n            .forEach((name) => r.db(db).table(c.id).indexDrop(name))\n            .run(conn)\n            .then((res) => {\n              if (res.errors) {\n                throw new Error('Failed to remove old indexes ' +\n                                `on collection ${c.id}: ${res.first_error}`);\n              }\n            }));\n      }\n    }\n\n    return Promise.all(promises);\n  }).then(cleanup).catch((err) => cleanup().then(() => { throw err; }));\n};\n\nconst file_exists = (filename) => {\n  try {\n    fs.accessSync(filename);\n  } catch (e) {\n    return false;\n  }\n  return true;\n};\n\nconst runSaveCommand = (options) => {\n  let conn, rdb_server;\n  const db = options.project_name;\n\n  const cleanup = () =>\n    Promise.all([\n      conn ? conn.close() : Promise.resolve(),\n      rdb_server ? rdb_server.close() : Promise.resolve(),\n    ]);\n\n  interrupt.on_interrupt(() => cleanup());\n\n  return Promise.resolve().then(() => {\n    if (options.start_rethinkdb) {\n      change_to_project_dir(options.project_path);\n    }\n  }).then(() => {\n    if (options.start_rethinkdb) {\n      return start_rdb_server({ quiet: !options.debug }).then((server) => {\n        rdb_server = server;\n        options.rdb_host = 'localhost';\n        options.rdb_port = server.driver_port;\n      });\n    }\n  }).then(() =>\n    r.connect({ host: options.rdb_host,\n                port: options.rdb_port,\n                user: options.rdb_user,\n                password: options.rdb_password,\n                timeout: options.rdb_timeout })\n  ).then((rdb_conn) => {\n    conn = rdb_conn;\n    return r.db(db).wait({ waitFor: 'ready_for_reads', timeout: 30 }).run(conn);\n  }).then(() =>\n    r.object('collections',\n             r.db(db).table('hz_collections')\n               .filter((row) => row('id').match('^hz_').not())\n               .coerceTo('array')\n               .map((row) =>\n                 row.merge({ indexes: r.db(db).table(row('id')).indexList() })),\n             'groups', r.db(db).table('hz_groups').coerceTo('array'))\n      .run(conn)\n  ).then((res) =>\n    new Promise((resolve) => {\n      // Only rename old file if saving to default .hz/schema.toml\n      if (options.out_file === '.hz/schema.toml' &&\n          file_exists(options.out_file)) {\n        // Rename existing file to have the current time appended to its name\n        const oldPath = path.resolve(options.out_file);\n        const newPath = `${path.resolve(options.out_file)}.${new Date().toISOString()}`;\n        fs.renameSync(oldPath, newPath);\n      }\n\n      const output = (options.out_file === '-') ? process.stdout :\n        fs.createWriteStream(options.out_file, { flags: 'w', defaultEncoding: 'utf8' });\n\n      // Output toml_str to schema.toml\n      const toml_str = schema_to_toml(res.collections, res.groups);\n      output.end(toml_str, resolve);\n    })\n  ).then(cleanup).catch((err) => cleanup().then(() => { throw err; }));\n};\n\nconst processConfig = (options) => {\n  // Determine if we are saving or applying and use appropriate config processing\n  switch (options.subcommand_name) {\n  case 'apply':\n    return processApplyConfig(options);\n  case 'save':\n    return processSaveConfig(options);\n  default:\n    throw new Error(`Unrecognized schema subcommand: \"${options.subcommand_name}\"`);\n  }\n};\n\n// Avoiding cyclical depdendencies\nmodule.exports = {\n  run: (args) =>\n    Promise.resolve().then(() => {\n      const options = processConfig(parseArguments(args));\n      // Determine if we are saving or applying and use appropriate run function\n      switch (options.subcommand_name) {\n      case 'apply':\n        return runApplyCommand(options);\n      case 'save':\n        return runSaveCommand(options);\n      default:\n        throw new Error(`Unrecognized schema subcommand: \"${options.subcommand_name}\"`);\n      }\n    }),\n  description: 'Apply and save the schema from a horizon database',\n  processApplyConfig,\n  runApplyCommand,\n  runSaveCommand,\n  parse_schema,\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/initialize_joi.js":"'use strict';\n\n// Issues a dummy joi validation to force joi to initialize its scripts.\n// This is used because tests will mock the filesystem, and the lazy\n// `require`s done by joi will no longer work at that point.\nmodule.exports = (joi) =>\n  joi.validate('', joi.any().when('', { is: '', then: joi.any() }));\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/version.js":"'use strict';\n\nconst package_json = require('../package.json');\n\nconst run = (args) =>\n  Promise.resolve().then(() => {\n    if (args && args.length) {\n      throw new Error('create-cert takes no arguments');\n    }\n    console.info(package_json.version);\n  });\n\nmodule.exports = {\n  run,\n  description: 'Print the version number of horizon',\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/create-cert.js":"'use strict';\nconst hasbin = require('hasbin');\nconst spawn = require('child_process').spawn;\n\nconst run = (args) => {\n  if (args.length) {\n    throw new Error('create-cert takes no arguments');\n  }\n\n  // TODO: user configuration?\n  const settings = {\n    binaryName: 'openssl',\n    keyOutName: 'horizon-key.pem',\n    certOutName: 'horizon-cert.pem',\n    algo: 'rsa',\n    bits: '2048',\n    days: '365',\n  };\n\n  // generate the arguments to the command\n  const binArgs = [ 'req', '-x509', '-nodes', '-batch',\n    '-newkey', `${settings.algo}:${settings.bits}`,\n    '-keyout', settings.keyOutName,\n    '-out', settings.certOutName,\n    '-days', settings.days,\n  ];\n\n  return new Promise((resolve, reject) => {\n    hasbin(settings.binaryName, (hasOpenSSL) => {\n      // show the invocation that's about to be run\n      console.log(`> ${settings.binaryName} ${binArgs.join(' ')}`);\n\n      // if we don't have openssl, bail\n      if (!hasOpenSSL) {\n        reject(new Error(`Missing ${settings.binaryName}. Make sure it is on the path.`));\n      }\n\n      // otherwise start openssl\n      const sslProc = spawn(settings.binaryName, binArgs);\n\n      // pipe output appropriately\n      sslProc.stdout.pipe(process.stdout, { end: false });\n      sslProc.stderr.pipe(process.stderr, { end: false });\n\n      // say nice things to the user when it's done\n      sslProc.on('error', reject);\n      sslProc.on('close', (code) => {\n        if (code) {\n          reject(new Error(`OpenSSL failed with code ${code}.`));\n        } else {\n          console.log('Everything seems to be fine. ' +\n                      'Remember to add your shiny new certificates to your Horizon config!');\n          resolve();\n        }\n      });\n    });\n  });\n};\n\nmodule.exports = {\n  run,\n  description: 'Generate a certificate',\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/make-token.js":"'use strict';\n\nconst interrupt = require('./utils/interrupt');\nconst config = require('./utils/config');\nconst horizon_server = require('@horizon/server');\n\nconst path = require('path');\nconst jwt = require('jsonwebtoken');\n\nconst r = horizon_server.r;\nconst logger = horizon_server.logger;\nconst argparse = require('argparse');\n\nconst parseArguments = (args) => {\n  const parser = new argparse.ArgumentParser({ prog: 'hz make-token' });\n\n  parser.addArgument(\n    [ '--token-secret' ],\n    { type: 'string', metavar: 'SECRET',\n      help: 'Secret key for signing the token.' });\n\n  parser.addArgument(\n    [ 'user' ],\n    { type: 'string', metavar: 'USER_ID',\n      help: 'The ID of the user to issue a token for.' });\n\n  return parser.parseArgs(args);\n};\n\nconst processConfig = (parsed) => {\n  let options;\n\n  options = config.default_options();\n\n  options = config.merge_options(\n    options, config.read_from_config_file(parsed.project_path));\n  options = config.merge_options(\n    options, config.read_from_secrets_file(parsed.project_path));\n  options = config.merge_options(options, config.read_from_env());\n  options = config.merge_options(options, config.read_from_flags(parsed));\n\n  if (options.project_name === null) {\n    options.project_name = path.basename(path.resolve(options.project_path));\n  }\n\n  return Object.assign(options, { user: parsed.user });\n};\n\nconst run = (args) => Promise.resolve().then(() => {\n  const options = processConfig(parseArguments(args));\n\n  if (options.token_secret === null) {\n    throw new Error('No token secret specified, unable to sign the token.');\n  }\n  const token = jwt.sign(\n    { id: options.user, provider: null },\n    new Buffer(options.token_secret, 'base64'),\n    { expiresIn: '1d', algorithm: 'HS512' }\n  );\n  console.log(`${token}`);\n});\n\nmodule.exports = {\n  run,\n  description: 'Generate a token to log in as a user',\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/migrate.js":"'use strict';\nconst chalk = require('chalk');\nconst r = require('rethinkdb');\nconst Promise = require('bluebird');\nconst argparse = require('argparse');\nconst runSaveCommand = require('./schema').runSaveCommand;\nconst fs = require('fs');\nconst accessAsync = Promise.promisify(fs.access);\nconst config = require('./utils/config');\nconst procPromise = require('./utils/proc-promise');\nconst interrupt = require('./utils/interrupt');\nconst change_to_project_dir = require('./utils/change_to_project_dir');\nconst parse_yes_no_option = require('./utils/parse_yes_no_option');\nconst start_rdb_server = require('./utils/start_rdb_server');\nconst NiceError = require('./utils/nice_error.js');\n\nconst VERSION_2_0 = [ 2, 0, 0 ];\n\nfunction run(cmdArgs) {\n  const options = processConfig(cmdArgs);\n  interrupt.on_interrupt(() => teardown());\n  return Promise.resolve().bind({ options })\n    .then(setup)\n    .then(validateMigration)\n    .then(makeBackup)\n    .then(renameUserTables)\n    .then(moveInternalTables)\n    .then(renameIndices)\n    .then(rewriteHzCollectionDocs)\n    .then(exportNewSchema)\n    .finally(teardown);\n}\n\nfunction green() {\n  const args = Array.from(arguments);\n  args[0] = chalk.green(args[0]);\n  console.log.apply(console, args);\n}\n\nfunction white() {\n  const args = Array.from(arguments);\n  args[0] = chalk.white(args[0]);\n  console.log.apply(console, args);\n}\n\nfunction processConfig(cmdArgs) {\n  // do boilerplate to get config args :/\n  const parser = new argparse.ArgumentParser({ prog: 'hz migrate' });\n\n  parser.addArgument([ 'project_path' ], {\n    default: '.',\n    nargs: '?',\n    help: 'Change to this directory before migrating',\n  });\n\n  parser.addArgument([ '--project-name', '-n' ], {\n    help: 'Name of the Horizon project server',\n  });\n\n  parser.addArgument([ '--connect', '-c' ], {\n    metavar: 'host:port',\n    default: undefined,\n    help: 'Host and port of the RethinkDB server to connect to.',\n  });\n\n  parser.addArgument([ '--rdb-user' ], {\n    default: 'admin',\n    metavar: 'USER',\n    help: 'RethinkDB User',\n  });\n\n  parser.addArgument([ '--rdb-password' ], {\n    default: undefined,\n    metavar: 'PASSWORD',\n    help: 'RethinkDB Password',\n  });\n\n  parser.addArgument([ '--start-rethinkdb' ], {\n    metavar: 'yes|no',\n    default: 'yes',\n    constant: 'yes',\n    nargs: '?',\n    help: 'Start up a RethinkDB server in the current directory',\n  });\n\n  parser.addArgument([ '--skip-backup' ], {\n    metavar: 'yes|no',\n    default: 'no',\n    constant: 'yes',\n    nargs: '?',\n    help: 'Whether to perform a backup of rethinkdb_data' +\n      ' before migrating',\n  });\n\n  parser.addArgument([ '--nonportable-backup' ], {\n    metavar: 'yes|no',\n    default: 'no',\n    constant: 'yes',\n    nargs: '?',\n    help: 'Allows creating a backup that is not portable, ' +\n      \"but doesn't require the RethinkDB Python driver to be \" +\n      'installed.',\n  });\n\n  const parsed = parser.parseArgs(cmdArgs);\n  const confOptions = config.read_from_config_file(parsed.project_path);\n  const envOptions = config.read_from_env();\n  config.merge_options(confOptions, envOptions);\n  // Pull out the relevant settings from the config file\n  const options = {\n    project_path: parsed.project_path || '.',\n    project_name: parsed.project_name || confOptions.project_name,\n    rdb_host: parsed.rdb_host || confOptions.rdb_host || 'localhost',\n    rdb_port: parsed.rdb_port || confOptions.rdb_port || 28015,\n    rdb_user: parsed.rdb_user || confOptions.rdb_user || 'admin',\n    rdb_password: parsed.rdb_password || confOptions.rdb_password || '',\n    start_rethinkdb: parse_yes_no_option(parsed.start_rethinkdb),\n    skip_backup: parse_yes_no_option(parsed.skip_backup),\n    nonportable_backup: parse_yes_no_option(parsed.nonportable_backup),\n  };\n  // sets rdb_host and rdb_port from connect if necessary\n  if (parsed.connect) {\n    config.parse_connect(parsed.connect, options);\n  }\n\n  if (options.project_name == null) {\n    throw new NiceError('No project_name given', {\n      description: `\\\nThe project_name is needed to migrate from the v1.x format the v.2.0 format. \\\nIt wasn't passed on the command line or found in your config.`,\n      suggestions: [\n        'pass the --project-name option to hz migrate',\n        'add the \"project_name\" key to your .hz/config.toml',\n      ] });\n  }\n  return options;\n}\n\nfunction setup() {\n  // Start rethinkdb server if necessary\n  // Connect to whatever rethinkdb server we're using\n  white('Setup');\n  return Promise.resolve().then(() => {\n    if (this.options.project_path && this.options.project_path !== '.') {\n      green(` ├── Changing to directory ${this.options.project_path}`);\n      change_to_project_dir(this.options.project_path);\n    }\n  }).then(() => {\n    // start rethinkdb server if necessary\n    if (this.options.start_rethinkdb) {\n      green(' ├── Starting RethinkDB server');\n      return start_rdb_server({ quiet: true }).then((server) => {\n        this.rdb_server = server;\n        this.options.rdb_host = 'localhost';\n        this.options.rdb_port = server.driver_port;\n      });\n    }\n  }).then(() => {\n    green(' ├── Connecting to RethinkDB');\n    return r.connect({\n      host: this.options.rdb_host,\n      port: this.options.rdb_port,\n      user: this.options.rdb_user,\n      password: this.options.rdb_password,\n    });\n  }).then((conn) => {\n    green(' └── Successfully connected');\n    this.conn = conn;\n  });\n}\n\nfunction teardown() {\n  return Promise.resolve().then(() => {\n    white('Cleaning up...');\n    // close the rethinkdb connection\n    if (this.conn) {\n      green(' ├── Closing rethinkdb connection');\n      return this.conn.close();\n    }\n  }).then(() => {\n    // shut down the rethinkdb server if we started it\n    if (this.rdb_server) {\n      green(' └── Shutting down rethinkdb server');\n      return this.rdb_server.close();\n    }\n  });\n}\n\nfunction validateMigration() {\n  // check that `${project}_internal` exists\n  const project = this.options.project_name;\n  const internalNotFound = `Database named '${project}_internal' wasn't found`;\n  const tablesHaveHzPrefix = `Some tables in ${project} have an hz_ prefix`;\n  const checkForHzTables = r.db('rethinkdb')\n          .table('table_config')\n          .filter({ db: project })('name')\n          .contains((x) => x.match('^hz_'))\n          .branch(r.error(tablesHaveHzPrefix), true);\n  const waitForCollections = r.db(`${project}_internal`)\n          .table('collections')\n          .wait({ timeout: 30 })\n          .do(() => r.db(project).tableList())\n          .forEach((tableName) =>\n            r.db(project).table(tableName).wait({ timeout: 30 })\n          );\n\n  return Promise.resolve().then(() => {\n    white('Validating current schema version');\n    return r.dbList().contains(`${project}_internal`)\n      .branch(true, r.error(internalNotFound))\n      .do(() => checkForHzTables)\n      .do(() => waitForCollections)\n      .run(this.conn)\n      .then(() => green(' └── Pre-2.0 schema found'))\n      .catch((e) => {\n        if (e.msg === internalNotFound) {\n          throw new NiceError(e.msg, {\n            description: `\\\nThis could happen if you don't have a Horizon app in this database, or if \\\nyou've already migrated this database to the v2.0 format.`,\n          });\n        } else if (e.msg === tablesHaveHzPrefix) {\n          throw new NiceError(e.msg, {\n            description: `This could happen if you've already migrated \\\nthis database to the v2.0 format.`,\n          });\n        } else {\n          throw e;\n        }\n      });\n  });\n}\n\nfunction makeBackup() {\n  // shell out to rethinkdb dump\n  const rdbHost = this.options.rdb_host;\n  const rdbPort = this.options.rdb_port;\n\n  if (this.options.skip_backup) {\n    return Promise.resolve();\n  }\n\n  white('Backing up rethinkdb_data directory');\n\n  if (this.options.nonportable_backup) {\n    return nonportableBackup();\n  }\n\n  return procPromise('rethinkdb', [\n    'dump',\n    '--connect',\n    `${rdbHost}:${rdbPort}`,\n  ]).then(() => {\n    green(' └── Backup completed');\n  }).catch((e) => {\n    if (e.message.match(/Python driver/)) {\n      throw new NiceError('The RethinkDB Python driver is not installed.', {\n        description: `Before we migrate to the v2.0 format, we should do a \\\nbackup of your RethinkDB database in case anything goes wrong. Unfortunately, \\\nwe can't use the rethinkdb dump command to do a backup because you don't have \\\nthe RethinkDB Python driver installed on your system.`,\n        suggestions: [\n          `Install the Python driver with the instructions found at: \\\nhttp://www.rethinkdb.com/docs/install-drivers/python/`,\n          `Pass the --nonportable-backup flag to hz migrate. This flag uses \\\nthe tar command to make a backup, but the backup is not safe to use on \\\nanother machine or to create replicas from. This option should not be used \\\nif RethinkDB is currently running. It should also not be used if the \\\nrethinkdb_data/ directory is not in the current directory.`,\n        ] });\n    } else {\n      throw e;\n    }\n  });\n}\n\nfunction nonportableBackup() {\n  // Uses tar to do an unsafe backup\n  const timestamp = new Date().toISOString().replace(/:/g, '_');\n  return procPromise('tar', [\n    '-zcvf', // gzip, compress, verbose, filename is...\n    `rethinkdb_data.nonportable-backup.${timestamp}.tar.gz`,\n    'rethinkdb_data', // directory to back up\n  ]).then(() => {\n    green(' └── Nonportable backup completed');\n  });\n}\n\nfunction renameUserTables() {\n  // for each table listed in ${project}_internal.collections\n  // rename the table name to the collection name\n  const project = this.options.project_name;\n  return Promise.resolve().then(() => {\n    white('Removing suffix from user tables');\n    return r.db(`${project}_internal`).wait({ timeout: 30 }).\n      do(() => r.db(`${project}_internal`).table('collections')\n         .forEach((collDoc) => r.db('rethinkdb').table('table_config')\n                  .filter({ db: project, name: collDoc('table') })\n                  .update({ name: collDoc('id') }))\n        ).run(this.conn)\n      .then(() => green(' └── Suffixes removed'));\n  });\n}\n\nfunction moveInternalTables() {\n  // find project_internal\n  // move all tables from ${project}_internal.${table} to ${project}.hz_${table}\n  //   - except for users, don't add hz_prefix, but move its db\n  const project = this.options.project_name;\n  return Promise.resolve().then(() => {\n    white(`Moving internal tables from ${project}_internal to ${project}`);\n    return r.db('rethinkdb').table('table_config')\n      .filter({ db: `${project}_internal` })\n      .update((table) => ({\n        db: project,\n        name: r.branch(\n          table('name').ne('users'),\n          r('hz_').add(table('name')),\n          'users'),\n      })).run(this.conn)\n      .then(() => green(' ├── Internal tables moved'));\n  }).then(() => {\n    // delete project_internal\n    green(` └── Deleting empty \"${project}_internal\" database`);\n    return r.dbDrop(`${project}_internal`).run(this.conn);\n  });\n}\n\nfunction renameIndices() {\n  // for each user $table in ${project}\n  //    for each index in ${table}\n  //        parse the old name into array of field names.\n  //        rename to `hz_${JSON.stringify(fields)}`\n  const project = this.options.project_name;\n  return Promise.resolve().then(() => {\n    white('Renaming indices to new JSON format');\n    return r.db(project).tableList().forEach((tableName) =>\n      r.db(project).table(tableName).indexList().forEach((indexName) =>\n        r.db(project).table(tableName)\n          .indexRename(indexName, rename(indexName))\n      )\n    ).run(this.conn)\n    .then(() => green(' └── Indices renamed.'));\n  });\n\n  function rename(name) {\n    // ReQL to rename the index name to the new format\n    const initialState = {\n      escaped: false,\n      field: '',\n      fields: [ ],\n    };\n    return name.split('')\n      .fold(initialState, (acc, c) =>\n        r.branch(\n          acc('escaped'),\n            acc.merge({\n              escaped: false,\n              field: acc('field').add(c),\n            }),\n          c.eq('\\\\'),\n            acc.merge({ escaped: true }),\n          c.eq('_'),\n            acc.merge({\n              fields: acc('fields').append(acc('field')),\n              field: '',\n            }),\n          acc.merge({ field: acc('field').add(c) })\n        )\n      ).do((state) =>\n          // last field needs to be appended to running list\n          state('fields').append(state('field'))\n          // wrap each field in an array\n          .map((field) => [ field ])\n         )\n      .toJSON()\n      .do((x) => r('hz_').add(x));\n  }\n}\n\nfunction rewriteHzCollectionDocs() {\n  // for each document in ${project}.hz_collections\n  //   delete the table field\n  const project = this.options.project_name;\n  return Promise.resolve().then(() => {\n    white('Rewriting hz_collections to new format');\n    return r.db(project).table('hz_collections')\n      .update({ table: r.literal() })\n      .run(this.conn);\n  }).then(() => green(' ├── \"table\" field removed'))\n    .then(() => r.db(project).table('hz_collections')\n          .insert({ id: 'users' })\n          .run(this.conn))\n    .then(() => green(' ├── Added document for \"users\" table'))\n    .then(() => r.db(project).table('hz_collections')\n          .insert({ id: 'hz_metadata', version: VERSION_2_0 })\n          .run(this.conn))\n    .then(() => green(' └── Adding the metadata document with schema version:' +\n                      `${JSON.stringify(VERSION_2_0)}`));\n}\n\nfunction exportNewSchema() {\n  // Import and run schema save process, giving it a different\n  // filename than schema.toml\n  const timestamp = new Date().toISOString().replace(/:/g, '_');\n  return accessAsync('.hz/schema.toml', fs.R_OK | fs.F_OK)\n    .then(() => `.hz/schema.toml.migrated.${timestamp}`)\n    .catch(() => '.hz/schema.toml') // if no schema.toml\n    .then((schemaFile) => {\n      white(`Exporting the new schema to ${schemaFile}`);\n      return runSaveCommand({\n        rdb_host: this.options.rdb_host,\n        rdb_port: this.options.rdb_port,\n        rdb_user: this.options.rdb_user,\n        rdb_password: this.options.rdb_password,\n        out_file: schemaFile,\n        project_name: this.options.project_name,\n      });\n    }).then(() => green(' └── Schema exported'));\n}\n\nmodule.exports = {\n  run,\n  description: 'migrate an older version of horizon to a newer one',\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/proc-promise.js":"'use strict';\nconst Promise = require('bluebird');\nconst childProcess = require('child_process');\n\nfunction procPromise() {\n  // Takes the same arguments as child_process.spawn\n  const args = Array.prototype.slice.call(arguments);\n  return new Promise((resolve, reject) => {\n    const proc = childProcess.spawn.apply(childProcess, args);\n    proc.stderr.setEncoding('utf8');\n    proc.stdout.setEncoding('utf8');\n    proc.on('exit', (code) => {\n      if (code === 0) {\n        resolve(proc);\n      } else {\n        const err = new Error(proc.stderr.read());\n        err.exitCode = code;\n        reject(err);\n      }\n    });\n  });\n}\n\nmodule.exports = procPromise;\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/.eslintrc.js":"const OFF = 0;\nconst WARN = 1;\nconst ERROR = 2;\n\nmodule.exports = {\n  extends: \"../.eslintrc.js\",\n  rules: {\n    \"max-len\": [ ERROR, 100 ],\n    \"no-invalid-this\": [ OFF ]\n  },\n  env: {\n    \"es6\": true,\n    \"node\": true,\n    \"mocha\": true,\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-horizon/node_modules/horizon/src/utils/rm_sync_recursive.js":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst rmdirSyncRecursive = (dir) => {\n  try {\n    fs.readdirSync(dir).forEach((item) => {\n      const full_path = path.join(dir, item);\n      if (fs.statSync(full_path).isDirectory()) {\n        rmdirSyncRecursive(full_path);\n      } else {\n        fs.unlinkSync(full_path);\n      }\n    });\n    fs.rmdirSync(dir);\n  } catch (err) { /* Do nothing */ }\n};\n\nmodule.exports = rmdirSyncRecursive;\n"}